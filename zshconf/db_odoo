#!/usr/bin/env bash

# PostgreSQL Docker Configuration
readonly POSTGRES_CONTAINER="${POSTGRES_CONTAINER:-local-postgres}"  # Container name
readonly POSTGRES_PORT="${POSTGRES_PORT:-5432}"
readonly POSTGRES_HOST="${POSTGRES_HOST:-localhost}"
readonly DB_USER="${DB_USER:-odoo}"
readonly DB_ADMIN_USER="${DB_ADMIN_USER:-postgres}"
readonly DB_PASSWORD="${DB_PASSWORD:-odoo}"
readonly DB_ADMIN_PASSWORD="${DB_ADMIN_PASSWORD:-postgres}"

function docker_psql() {
    local user="${1}"
    local password="${2}"
    shift 2
    docker exec -i "${POSTGRES_CONTAINER}" \
        env PGPASSWORD="${password}" \
        psql -U "${user}" "$@"
}

# Helper function for Docker PostgreSQL tools
function docker_pg() {
    local tool="${1}"  # pg_dump, dropdb, createdb, etc.
    local user="${2}"
    local password="${3}"
    shift 3
    docker exec -i "${POSTGRES_CONTAINER}" \
        env PGPASSWORD="${password}" \
        "${tool}" -U "${user}" "$@"
}

function validate_db_name() {
    local db_name="${1}"
    if [[ ! "${db_name}" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo "Error: Invalid database name format: ${db_name}" >&2
        return 1
    fi
    return 0
}

function db_odoo_filestore() {
    # arg$1 - Database name
    # arg$2 - Source filestore path (can be relative)
    if [[ $# -lt 2 ]]; then
        echo "Error: Database name and filestore path required"
        return 1
    fi

    local db_name=$1
    local filestore_source=$2
    local filestore_dest="$HOME/.local/share/Odoo/filestore/${db_name}"

    # Check if source filestore exists
    if [[ ! -d "$filestore_source" ]]; then
        echo "Error: Source filestore not found at: $filestore_source"
        return 1
    fi

    # Create parent directory if it doesn't exist
    mkdir -p "$HOME/.local/share/Odoo/filestore"

    if [[ -d "$filestore_dest" ]]; then
        echo "Removing existing filestore at: $filestore_dest"
        rm -rf "$filestore_dest"
    fi

    echo "Moving filestore from $filestore_source to $filestore_dest"
    mv "$filestore_source" "$filestore_dest"

    echo "Filestore moved successfully for database: $db_name"
}

function db_odoo_reset() {
    # arg$1 - Database name
    if [[ $# -eq 0 ]] ; then
        echo 'No db name given. exiting'
        return 1
    fi

    local db_name="${1}"

    if ! validate_db_name "${db_name}"; then
        return 1
    fi

    echo "Deactivating Crons"

    # Deactivate crons
    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "UPDATE ir_cron SET active = false;" || {
        echo "Error: Failed to deactivate crons" >&2
        return 1
    }

    # Delete mail servers
    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "DELETE FROM fetchmail_server;" || {
        echo "Error: Failed to delete fetchmail servers" >&2
        return 1
    }

    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "DELETE FROM ir_mail_server;" || {
        echo "Error: Failed to delete mail servers" >&2
        return 1
    }

    db_odoo_fix_code "${db_name}" || return 1
    db_odoo_admin "${db_name}" || return 1
    db_odoo_remove_report_url "${db_name}" || return 1
    db_odoo_disable_users_totp "${db_name}" || return 1
    db_odoo_reset_assets "${db_name}" || return 1

    echo "Database ${db_name} ready for test"
}

function db_odoo_fix_code() {
    # arg$1 - Database name
    if [[ $# -eq 0 ]] ; then
        echo 'No db name given. exiting'
        return 1
    fi

    local db_name="${1}"

    if ! validate_db_name "${db_name}"; then
        return 1
    fi

    local uuid=$(uuidgen)
    local today_date="$(date -d '+1 year' +'%Y-%m-%d %H:%M:%S')"

    echo "Delete enterprise code"
    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "DELETE FROM ir_config_parameter WHERE key LIKE '%enterprise_code%';" || {
        echo "Error: Failed to delete enterprise code" >&2
        return 1
    }

    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "UPDATE ir_config_parameter SET value = \$\$${uuid}\$\$ WHERE key LIKE '%uuid%';" || {
        echo "Error: Failed to update UUID" >&2
        return 1
    }

    echo "Update database create date"
    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "UPDATE ir_config_parameter SET value = \$\$${today_date}\$\$ WHERE key = 'database.expiration_date';" || {
        echo "Error: Failed to update expiration date" >&2
        return 1
    }
}

function db_odoo_remove_report_url() {
    # arg$1 - Database name
    if [[ $# -eq 0 ]] ; then
        echo 'No db name given. exiting'
        return 1
    fi

    local db_name="${1}"

    if ! validate_db_name "${db_name}"; then
        return 1
    fi

    echo "Deleting report.url key"
    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "DELETE FROM ir_config_parameter WHERE key = 'report.url';" || {
        echo "Error: Failed to delete report.url" >&2
        return 1
    }
}

function db_odoo_reset_assets() {
    # arg$1 - Database name
    if [[ $# -eq 0 ]] ; then
        echo 'No db name given. exiting'
        return 1
    fi

    local db_name="${1}"

    if ! validate_db_name "${db_name}"; then
        return 1
    fi

    echo "Resetting assets"
    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "DELETE FROM ir_attachment WHERE url LIKE '/web/assets/%';" || {
        echo "Error: Failed to reset assets" >&2
        return 1
    }
}

function db_odoo_disable_users_totp() {
    # arg$1 - Database name
    if [[ $# -eq 0 ]] ; then
        echo 'No db name given. exiting'
        return 1
    fi

    local db_name="${1}"

    if ! validate_db_name "${db_name}"; then
        return 1
    fi

    echo "Disable two factor authentication"
    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "UPDATE res_users SET totp_secret = NULL;" || {
        echo "Error: Failed to disable TOTP" >&2
        return 1
    }

    echo "Disable auth_password_policy.minlength"
    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "DELETE FROM ir_config_parameter WHERE key = 'auth_password_policy.minlength';" || {
        echo "Error: Failed to disable minlegth password" >&2
        return 1
    }
}

function db_odoo_disable_customziation() {
    # arg$1 - Database name
    # arg$2 - user_id
    if [[ $# -eq 0 ]] ; then
        echo 'No db name given. exiting'
        return 1
    fi

    local db_name="${1}"
    local user_id=2

    if ! validate_db_name "${db_name}"; then
        return 1
    fi

    if [[ $# -eq 2 ]] ; then
        user_id="${2}"
        # Validate user_id is numeric
        if ! [[ "${user_id}" =~ ^[0-9]+$ ]]; then
            echo "Error: Invalid user_id format: ${user_id}" >&2
            return 1
        fi
    fi

    echo "Disable studio and extra customization"

    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "DELETE FROM ir_ui_view WHERE create_uid = ${user_id};" || {
        echo "Error: Failed to delete UI views" >&2
        return 1
    }

    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "DELETE FROM ir_model_fields WHERE create_uid = ${user_id};" || {
        echo "Error: Failed to delete model fields" >&2
        return 1
    }

    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "DELETE FROM ir_model WHERE create_uid = ${user_id};" || {
        echo "Error: Failed to delete models" >&2
        return 1
    }
}

function db_odoo_admin() {
    # arg$1 - Database name
    # arg$2 - Login to reset password
    if [[ $# -eq 0 ]] ; then
        echo 'No db name given. exiting'
        return 1
    fi

    local db_name="${1}"
    local db_login="admin"

    if ! validate_db_name "${db_name}"; then
        return 1
    fi

    if [[ $# -eq 2 ]] ; then
        db_login="${2}"
        # Validate login to prevent injection (allow alphanumeric, underscore, dash, @, .)
        if ! [[ "${db_login}" =~ ^[a-zA-Z0-9_@.-]+$ ]]; then
            echo "Error: Invalid login format: ${db_login}" >&2
            return 1
        fi
    fi

    echo "Changing admin username and password for user ${db_login}"

    # Use dollar-quoting to safely escape the login parameter
    docker_psql "${DB_USER}" "${DB_PASSWORD}" -d "${db_name}" \
        -c "UPDATE res_users SET password = 'admin', login = 'admin', active = True WHERE login = \$\$${db_login}\$\$;" || {
        echo "Error: Failed to update admin user" >&2
        return 1
    }
}

function db_restore() {
    # Parse arguments
    local db_name=""
    local restore_file=""
    local filestore_path=""
    local skip_clean=false

    # Process arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --skip-clean)
                skip_clean=true
                shift
                ;;
            *)
                if [[ -z "$db_name" ]]; then
                    db_name="$1"
                elif [[ -z "$restore_file" ]]; then
                    restore_file="$1"
                elif [[ -z "$filestore_path" ]]; then
                    filestore_path="$1"
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$db_name" ]]; then
        echo 'No db name given. exiting'
        return 1
    fi

    if ! validate_db_name "${db_name}"; then
        return 1
    fi

    if [[ -z "$restore_file" ]]; then
        echo 'No restore file given. exiting'
        return 1
    fi

    # Check if restore file exists
    if [[ ! -f "$restore_file" ]]; then
        echo "Error: Restore file not found: $restore_file" >&2
        return 1
    fi

    # Terminate all connections to the database before dropping
    echo "Terminating existing connections to database ${db_name}..."
    docker_psql "${DB_ADMIN_USER}" "${DB_ADMIN_PASSWORD}" -d postgres \
        -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '${db_name}' AND pid <> pg_backend_pid();" >/dev/null 2>&1 || {
        echo "Warning: Could not terminate connections to ${db_name}" >&2
    }

    # Drop and recreate database
    docker_pg dropdb "${DB_USER}" "${DB_PASSWORD}" --if-exists "${db_name}" || {
        echo "Warning: Could not drop database ${db_name}" >&2
    }

    docker_pg createdb "${DB_USER}" "${DB_PASSWORD}" "${db_name}" || {
        echo "Error: Failed to create database ${db_name}" >&2
        return 1
    }

    # Load sql dump - pipe file content to docker
    echo "Loading SQL dump into ${db_name}..."
    cat "${restore_file}" | docker_psql "${DB_USER}" "${DB_PASSWORD}" "${db_name}" || {
        echo "Error: Failed to restore database from ${restore_file}" >&2
        return 1
    }

    # Handle filestore if provided
    if [[ -n "$filestore_path" ]]; then
        db_odoo_filestore "$db_name" "$filestore_path" || {
            echo "Warning: Failed to restore filestore" >&2
        }
    fi

    if [[ "$skip_clean" != true ]]; then
        db_odoo_reset "$db_name" || {
            echo "Warning: Failed to reset database" >&2
        }
    fi
    echo "Restored db $db_name"
}

function db_backup {
    # arg$1 - Database name to backup
    # arg$2 - boolean with default false. If true is passed,
    #         database will be compressed to be send to odoo for upgrading
    if [[ $# -eq 0 ]]; then
        echo "No database name entered, exiting"
        return 1
    fi

    local database="${1}"

    if ! validate_db_name "${database}"; then
        return 1
    fi

    local now="$(date +'%Y_%m_%d_%H_%M_%S')"
    local output_file

    echo "Going to backup ${database} database, please wait"

    if [[ "${2}" = true ]]; then
        output_file="${database}_bak_${now}.gz"
        docker_pg pg_dump "${DB_USER}" "${DB_PASSWORD}" -v "${database}" | gzip -9 > "${output_file}" || {
            echo "Error: Failed to create compressed backup" >&2
            return 1
        }
    else
        output_file="${database}_bak_${now}.sql"
        docker_pg pg_dump "${DB_USER}" "${DB_PASSWORD}" -v "${database}" > "${output_file}" || {
            echo "Error: Failed to create backup" >&2
            return 1
        }
    fi

    echo "Backup for database can be found @ ${output_file}"
}

function db_dump {
    if [[ $# -eq 0 ]]; then
        echo "No database name provided. Doing nothing."
        return 1
    fi

    local database="${1}"
    local output_file

    if ! validate_db_name "${database}"; then
        return 1
    fi

    if [[ $# -eq 2 ]]; then
        output_file="${2}.dump"
    else
        output_file="${database}.dump"
    fi

    docker_pg pg_dump "${DB_USER}" "${DB_PASSWORD}" -F c "${database}" > "${output_file}" || {
        echo "Error: Failed to create database dump" >&2
        return 1
    }

    echo "Database dump of ${database} to ${output_file} done."
}

function check_dump_version {
    local dump_file="${1}"

    # Extract version byte from dump header (offset 5)
    local version_byte=$(od -An -N1 -j5 -td1 < "${dump_file}" | tr -d ' ')

    # Map version to PostgreSQL version
    case "${version_byte}" in
        14) echo "15" ;;
        15) echo "16" ;;
        13) echo "14" ;;
        12) echo "13" ;;
        11) echo "12" ;;
        *) echo "unknown (byte: ${version_byte})" ;;
    esac
}

function db_dump_restore {
    # Parse arguments
    local db_name=""
    local restore_file=""
    local filestore_path=""
    local skip_clean=false

    # Process arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --skip-clean)
                skip_clean=true
                shift
                ;;
            *)
                if [[ -z "$db_name" ]]; then
                    db_name="$1"
                elif [[ -z "$restore_file" ]]; then
                    restore_file="$1"
                elif [[ -z "$filestore_path" ]]; then
                    filestore_path="$1"
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$db_name" ]]; then
        echo "No database name provided. Doing nothing."
        return 1
    fi

    if ! validate_db_name "${db_name}"; then
        return 1
    fi

    if [[ -z "$restore_file" ]]; then
        echo "No restore file provided. Doing nothing."
        return 1
    fi

    # Check if restore file exists
    if [[ ! -f "$restore_file" ]]; then
        echo "Error: Restore file not found: $restore_file" >&2
        return 1
    fi

    # Check dump version compatibility
    local dump_pg_version=$(check_dump_version "${restore_file}")
    local container_pg_version=$(docker exec "${POSTGRES_CONTAINER}" psql --version | grep -oE '[0-9]+' | head -1)

    echo "Dump created with PostgreSQL ${dump_pg_version}, container has PostgreSQL ${container_pg_version}"

    # Terminate all connections to the database before dropping
    echo "Terminating existing connections to database ${db_name}..."
    docker_psql "${DB_ADMIN_USER}" "${DB_ADMIN_PASSWORD}" -d postgres \
        -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '${db_name}' AND pid <> pg_backend_pid();" >/dev/null 2>&1 || {
        echo "Warning: Could not terminate connections to ${db_name}" >&2
    }

    echo "Create an empty database ${db_name}"
    docker_pg dropdb "${DB_USER}" "${DB_PASSWORD}" --if-exists "${db_name}" || {
        echo "Warning: Could not drop database ${db_name}" >&2
    }

    docker_pg createdb "${DB_USER}" "${DB_PASSWORD}" "${db_name}" || {
        echo "Error: Failed to create database ${db_name}" >&2
        return 1
    }

    echo "Start restoring ${restore_file} in ${db_name}"
    cat "${restore_file}" | docker exec -i "${POSTGRES_CONTAINER}" \
        env PGPASSWORD="${DB_PASSWORD}" \
        pg_restore -U "${DB_USER}" --no-owner --no-acl -d "${db_name}" || {
        echo "Error: Failed to restore database from ${restore_file}" >&2
        return 1
    }

    # Handle filestore if provided
    if [[ -n "$filestore_path" ]]; then
        db_odoo_filestore "$db_name" "$filestore_path" || {
            echo "Warning: Failed to restore filestore" >&2
        }
    fi

    if [[ "$skip_clean" != true ]]; then
        db_odoo_reset "$db_name" || {
            echo "Warning: Failed to reset database" >&2
        }
    fi
    echo "Restored database ${db_name}"
}

function db_drop {
    if [[ $# -eq 0 ]]; then
        echo "No database name provided. Doing nothing."
        return 1
    fi

    local pattern="${1}"
    local databases=()
    local system_dbs=("postgres" "template0" "template1")
    local is_pattern=false

    # Check if pattern contains wildcards
    if [[ "${pattern}" == *"*"* ]] || [[ "${pattern}" == *"?"* ]]; then
        is_pattern=true
        # Get list of databases matching the pattern with proper error handling
        local db_list
        if ! db_list=$(docker_psql "${DB_USER}" "${DB_PASSWORD}" -d postgres -t -c "SELECT datname FROM pg_database WHERE datname NOT IN ('postgres', 'template0', 'template1') ORDER BY datname;"); then
            echo "Error: Failed to list databases" >&2
            return 1
        fi

        # Convert pattern to regex safely using parameter expansion
        local regex_pattern="${pattern//\*/.+}"
        regex_pattern="${regex_pattern//\?/.}"
        regex_pattern="^${regex_pattern}$"

        # Filter databases that match the pattern with validation
        while IFS= read -r db; do
            db="${db#"${db%%[![:space:]]*}"}"  # Trim leading whitespace
            db="${db%"${db##*[![:space:]]}"}"  # Trim trailing whitespace

            if [[ -n "${db}" ]] && [[ "${db}" =~ ${regex_pattern} ]]; then
                # Validate each matched database name
                if validate_db_name "${db}"; then
                    # Additional check for system databases
                    local is_system=false
                    for sys_db in "${system_dbs[@]}"; do
                        if [[ "${db}" == "${sys_db}" ]]; then
                            is_system=true
                            break
                        fi
                    done

                    if [[ "${is_system}" == false ]]; then
                        databases+=("${db}")
                    else
                        echo "Warning: Skipping system database: ${db}" >&2
                    fi
                else
                    echo "Warning: Skipping invalid database name: ${db}" >&2
                fi
            fi
        done <<< "${db_list}"
    else
        # Single database - treat it as a list with one item
        local database="${pattern}"

        # Check if trying to delete system database
        for sys_db in "${system_dbs[@]}"; do
            if [[ "${database}" == "${sys_db}" ]]; then
                echo "Error: Cannot delete system database '${database}'"
                return 1
            fi
        done

        if ! validate_db_name "${database}"; then
            return 1
        fi

        databases+=("${database}")
    fi

    if [[ ${#databases[@]} -eq 0 ]]; then
        echo "No databases found matching pattern: ${pattern}"
        return 1
    fi

    # Show databases that will be deleted and ask for confirmation if multiple
    if [[ ${#databases[@]} -gt 1 ]]; then
        echo "The following databases will be deleted:"
        printf '  - %s\n' "${databases[@]}"
        echo
        echo -n "Press Y to confirm deletion, any other key to cancel: "
        read -k 1 REPLY
        echo

        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Deletion cancelled."
            return 0
        fi
    fi

    local failed_count=0
    for database in "${databases[@]}"; do
        if [[ ${#databases[@]} -gt 1 ]]; then
            echo "Dropping database: ${database}"
        fi

        # Terminate active connections using proper parameterized format
        docker_psql "${DB_ADMIN_USER}" "${DB_ADMIN_PASSWORD}" \
            -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '${database//\'/\'\'}' AND pid <> pg_backend_pid();" >/dev/null 2>&1

        # Drop the database using the safe dropdb command
        # Capture output to check if database existed
        local drop_output=$(docker_pg dropdb "${DB_USER}" "${DB_PASSWORD}" --if-exists "${database}" 2>&1)
        local drop_status=$?

        if [[ ${drop_status} -ne 0 ]]; then
            echo "Error: Failed to drop database ${database}" >&2
            ((failed_count++))
            continue
        fi

        # Check if database actually existed (NOTICE message means it didn't exist)
        if [[ "${drop_output}" == *"NOTICE:"*"does not exist"* ]]; then
            echo "Database ${database} does not exist"
        else
            if [[ ${#databases[@]} -gt 1 ]]; then
                echo "Successfully dropped database: ${database}"
            else
                echo "Dropped database ${database}"
            fi
        fi
    done

    if [[ ${failed_count} -gt 0 ]]; then
        echo "Warning: Failed to drop ${failed_count} database(s)"
        return 1
    fi

    if [[ ${#databases[@]} -gt 1 ]]; then
        echo "All ${#databases[@]} database(s) dropped successfully."
    fi
}

function db_con {
    if [[ $# -eq 0 ]]; then
        echo "No database name provided. Doing nothing."
        return 1
    fi

    local database="${1}"

    if ! validate_db_name "${database}"; then
        return 1
    fi

    # Connect to database interactively
    docker exec -it "${POSTGRES_CONTAINER}" \
        env PGPASSWORD="${DB_PASSWORD}" \
        psql -U "${DB_USER}" "${database}"
}

function db_list {
    # List databases, optionally filtered by pattern
    # Usage: db_list [pattern]
    # Examples: db_list, db_list test, db_list "test_*"

    if [[ $# -eq 0 ]]; then
        # No pattern - show all databases
        docker_psql "${DB_USER}" "${DB_PASSWORD}" -d postgres --list
    else
        local pattern="${1}"

        # Check if pattern contains wildcards
        if [[ "${pattern}" == *"*"* ]] || [[ "${pattern}" == *"?"* ]]; then
            # Convert wildcards to regex for grep
            local grep_pattern="${pattern//\*/.*}"
            grep_pattern="${grep_pattern//\?/.}"
            # List databases and filter with grep
            docker_psql "${DB_USER}" "${DB_PASSWORD}" -d postgres --list | head -n 3
            docker_psql "${DB_USER}" "${DB_PASSWORD}" -d postgres --list | grep -E "^ ${grep_pattern}" || true
        else
            # Simple pattern - use grep for partial match
            docker_psql "${DB_USER}" "${DB_PASSWORD}" -d postgres --list | head -n 3
            docker_psql "${DB_USER}" "${DB_PASSWORD}" -d postgres --list | grep -i "${pattern}" || true
        fi
    fi
}


